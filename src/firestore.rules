/**
 * Core Philosophy: This ruleset enforces a hybrid security model tailored for a subscription-based video streaming service.
 * It combines three primary access control patterns:
 * 1. User Ownership: User-specific data, such as profiles and subscriptions, is strictly private and accessible only by the owning user or an administrator.
 * 2. Public Content: Core application content like courses, episodes, and policies is publicly readable by anyone, including unauthenticated users, to encourage discovery.
 * 3. Role-Based Access Control (RBAC): A simple but effective admin role is used to manage all public content and oversee user data.
 *
 * Data Structure:
 * - /users/{userId}/...: All data private to a specific user is nested under their unique user ID.
 * - /fields, /classifications, /courses, /policies: Top-level collections for publicly accessible application content.
 * - /roles_admin/{userId}: A dedicated collection where the existence of a document signifies that a user has administrative privileges.
 *
 * Key Security Decisions:
 * - Admin Supremacy: Users with an admin role have read/write access to all data to manage the platform. This role is granted by adding a document with their UID to the /roles_admin collection.
 * - User Data Privacy: The top-level /users collection cannot be listed, preventing user enumeration. A user can only access their own document and subcollections within /users/{userId}.
 * - Public Read, Admin Write: To keep content management secure, all public collections (/fields, /courses, etc.) can only be modified by administrators.
 * - Default Deny: All paths not explicitly matched are inaccessible.
 *
 * Denormalization for Authorization:
 * To ensure high performance and avoid complex `get()` calls in rules, authorization data is denormalized. For example, a user's subscription document at `/users/{userId}/subscriptions/{subscriptionId}` contains a `userId` field, which is validated against the path. This makes ownership checks fast and simple.
 *
 * Structural Segregation:
 * The data model clearly separates private user data (e.g., /users/{userId}/subscriptions) from public content (e.g., /courses). This segregation allows for simple, powerful list rules on entire collections without compromising security. For example, the client can freely list all courses, but can only list subscriptions for the currently authenticated user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document,
     * based on a provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the currently authenticated user has an admin role.
     * Admin status is determined by the existence of a document in the
     * /roles_admin collection corresponding to their user ID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the requesting user is either the owner or an admin.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    /**
     * On update/delete, checks that a document already exists before allowing the operation.
     * This prevents erroneous writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Combines owner/admin check with an existence check for update/delete operations.
     */
    function isExistingOwnerOrAdmin(userId) {
      return isOwnerOrAdmin(userId) && isExistingDoc();
    }
    
    // ----------------------------------------------------------------
    // Admin & User Roles
    // ----------------------------------------------------------------
    
    /**
     * @description Manages admin role assignments. Only existing admins can view or modify this collection.
     * @path /roles_admin/{userId}
     * @allow (get) An admin wants to check if another user is an admin.
     * @deny (create) A regular user tries to make themselves an admin.
     * @principle Enforces strict Role-Based Access Control (RBAC) for administrative privileges.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Defines rules for user profile documents and their subcollections.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwnerOrAdmin(userId);
      allow list: if isAdmin();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwnerOrAdmin(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwnerOrAdmin(userId);

      /**
       * @description Secures a user's subscription records.
       * @path /users/{userId}/subscriptions/{subscriptionId}
       */
      match /subscriptions/{subscriptionId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwnerOrAdmin(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwnerOrAdmin(userId);
      }
      
      /**
       * @description Secures a user's personal view history.
       * @path /users/{userId}/viewHistory/{logId}
       */
      match /viewHistory/{logId} {
        allow read, list, write: if isOwner(userId);
      }
    }
    
    /**
     * @description User profile change history. Writable by any signed-in user (for their own changes via server action).
     *              Readable only by admins.
     * @path /user_audit_logs/{logId}
     */
    match /user_audit_logs/{logId} {
        allow read, list: if isAdmin();
        allow create: if isSignedIn(); // Logged by server action on behalf of user
        allow update, delete: if false; // Immutable logs
    }
    
    /**
     * @description Global user's episode view logs for admin auditing.
     *              Writable by server action. Admins can list all logs.
     * @path /episode_view_logs/{logId}
     */
    match /episode_view_logs/{logId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn(); // Server action writes on behalf of user
      allow update, delete: if false; // Immutable logs
    }

    
    // ----------------------------------------------------------------
    // Public Content Collections (Admin-Managed)
    // ----------------------------------------------------------------
    
    /**
     * @description Stores top-level content categories. Publicly readable, but writable only by admins.
     * @path /fields/{fieldId}
     */
    match /fields/{fieldId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores content classifications/genres. Publicly readable, but writable only by admins.
     * @path /classifications/{classificationId}
     */
    match /classifications/{classificationId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores course metadata. Publicly readable, but writable only by admins.
     * @path /courses/{courseId}
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores episode metadata. Publicly readable, but writable only by admins.
     * @path /episodes/{episodeId}
     */
    match /episodes/{episodeId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    match /episodes/{episodeId}/comments/{commentId} {
      // Anyone can read comments
      allow get, list: if true;
      // Only signed-in users can create comments for themselves
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      // Only the owner of the comment or an admin can update/delete
      allow update, delete: if (isOwner(resource.data.userId) || isAdmin());
    }

    /**
     * @description Stores instructor profiles. Read-only for signed in users, writable by admins.
     * @path /instructors/{instructorId}
     */
    match /instructors/{instructorId} {
        allow read: if isSignedIn();
        allow write: if isAdmin();
    }
    
    /**
     * @description Stores legal and informational policies. Publicly readable, but writable only by admins.
     * @path /policies/{policyId}
     */
    match /policies/{policyId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores global application settings like footer info and hero content.
     * @path /settings/{settingId}
     */
    match /settings/{settingId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
  }
}
