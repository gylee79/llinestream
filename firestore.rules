/**
 * Core Philosophy: This ruleset enforces a hybrid security model tailored for a subscription-based video streaming service.
 * It combines three primary access control patterns:
 * 1. User Ownership: User-specific data, such as profiles and subscriptions, is strictly private and accessible only by the owning user or an administrator.
 * 2. Public Content: Core application content like courses, episodes, and policies is publicly readable by anyone, including unauthenticated users, to encourage discovery.
 * 3. Role-Based Access Control (RBAC): A simple but effective admin role is used to manage all public content and oversee user data.
 *
 * Data Structure:
 * - /users/{userId}/...: All data private to a specific user is nested under their unique user ID.
 * - /fields, /classifications, /courses, /policies: Top-level collections for publicly accessible application content.
 * - /roles_admin/{userId}: A dedicated collection where the existence of a document signifies that a user has administrative privileges.
 *
 * Key Security Decisions:
 * - Admin Supremacy: Users with an admin role have read/write access to all data to manage the platform. This role is granted by adding a document with their UID to the /roles_admin collection.
 * - User Data Privacy: The top-level /users collection cannot be listed, preventing user enumeration. A user can only access their own document and subcollections within /users/{userId}.
 * - Public Read, Admin Write: To keep content management secure, all public collections (/fields, /courses, etc.) can only be modified by administrators.
 * - Default Deny: All paths not explicitly matched are inaccessible.
 *
 * Denormalization for Authorization:
 * To ensure high performance and avoid complex `get()` calls in rules, authorization data is denormalized. For example, a user's subscription document at `/users/{userId}/subscriptions/{subscriptionId}` contains a `userId` field, which is validated against the path. This makes ownership checks fast and simple.
 *
 * Structural Segregation:
 * The data model clearly separates private user data (e.g., /users/{userId}/subscriptions) from public content (e.g., /courses). This segregation allows for simple, powerful list rules on entire collections without compromising security. For example, the client can freely list all courses, but can only list subscriptions for the currently authenticated user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document,
     * based on a provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the currently authenticated user has an admin role.
     * Admin status is determined by the existence of a document in the
     * /roles_admin collection corresponding to their user ID.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the requesting user is either the owner or an admin.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    /**
     * On update/delete, checks that a document already exists before allowing the operation.
     * This prevents erroneous writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }
    
    /**
     * Combines owner/admin check with an existence check for update/delete operations.
     */
    function isExistingOwnerOrAdmin(userId) {
      return isOwnerOrAdmin(userId) && isExistingDoc();
    }
    
    // ----------------------------------------------------------------
    // Admin & User Roles
    // ----------------------------------------------------------------
    
    /**
     * @description Manages admin role assignments. Only existing admins can view or modify this collection.
     * @path /roles_admin/{userId}
     * @allow (get) An admin wants to check if another user is an admin.
     * @deny (create) A regular user tries to make themselves an admin.
     * @principle Enforces strict Role-Based Access Control (RBAC) for administrative privileges.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Defines rules for user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user signs up and creates their own user profile document. `auth.uid` must match `userId`.
     * @deny (list) A malicious actor tries to list all documents in the `/users` collection.
     * @deny (update) A user tries to update another user's profile.
     * @principle Restricts access to a user's own data tree and allows self-creation of a profile.
     */
    match /users/{userId} {
      allow get: if isOwnerOrAdmin(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwnerOrAdmin(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwnerOrAdmin(userId);
    }
    
    /**
     * @description Secures a user's subscription records.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (create) A user (`auth.uid == userId`) creates a new subscription for themselves.
     * @deny (list) User 'A' tries to list the subscriptions of User 'B'.
     * @deny (update) A user tries to change the `userId` on an existing subscription document.
     * @principle Enforces document ownership and validates relational integrity between the path and document data.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get, list: if isOwnerOrAdmin(userId);
      allow create: if isOwnerOrAdmin(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwnerOrAdmin(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwnerOrAdmin(userId);
    }
    
    // ----------------------------------------------------------------
    // Public Content Collections (Admin-Managed)
    // ----------------------------------------------------------------
    
    /**
     * @description Stores top-level content categories. Publicly readable, but writable only by admins.
     * @path /fields/{fieldId}
     * @allow (get, list) Any user, including unauthenticated ones, can read the list of fields.
     * @deny (create) A regular authenticated user tries to add a new content field.
     * @principle Allows public read access for application content while securing writes to admins.
     */
    match /fields/{fieldId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores content classifications/genres. Publicly readable, but writable only by admins.
     * @path /classifications/{classificationId}
     * @allow (get, list) Any user can browse all available content classifications.
     * @deny (update) A regular user tries to change the subscription price of a classification.
     * @principle Allows public read access for application content while securing writes to admins.
     */
    match /classifications/{classificationId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores course metadata. Publicly readable, but writable only by admins.
     * @path /courses/{courseId}
     * @allow (get, list) Any user can list all courses to browse the catalog.
     * @deny (create) A regular user attempts to upload a new course.
     * @principle Allows public read access for application content while securing writes to admins.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }
    
    /**
     * @description Stores episode metadata within a course. Publicly readable, but writable only by admins.
     * @path /courses/{courseId}/episodes/{episodeId}
     * @allow (get, list) Any user can view the list of episodes for a given course.
     * @deny (delete) A regular user tries to delete an episode from a course.
     * @principle Allows public read access for application content while securing writes to admins.
     */
    match /courses/{courseId}/episodes/{episodeId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores instructor profiles. Writable and readable only by admins.
     * @path /instructors/{instructorId}
     * @allow (get, list, create, update, delete) An admin can manage instructor profiles.
     * @deny (any) Non-admins cannot access instructor data.
     * @principle Secures sensitive instructor information to administrators only.
     */
    match /instructors/{instructorId} {
        allow read, write: if isAdmin();
    }
    
    /**
     * @description Stores legal and informational policies. Publicly readable, but writable only by admins.
     * @path /policies/{policyId}
     * @allow (get, list) Any user can read the Terms of Service or Privacy Policy.
     * @deny (update) A regular user tries to modify the refund policy.
     * @principle Allows public read access for application content while securing writes to admins.
     */
    match /policies/{policyId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores global application settings like footer info and hero content.
     * @path /settings/{settingId}
     * @allow (get, list) Allows any user to read application settings.
     * @deny (create, update) Prevents non-admins from changing settings.
     * @principle Public information should be readable, but modification must be restricted to admins.
     */
    match /settings/{settingId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
  }
}

    