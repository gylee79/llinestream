# 비디오 처리, 보안 재생 및 오프라인 워크플로우

**목표:** 관리자가 비디오를 업로드하는 순간부터 최종 사용자가 온라인/오프라인에서 안전하게 시청하기까지의 전 과정을 자동화하고, 강력한 이중 암호화 및 워터마크 기술로 콘텐츠를 보호하는 서버리스 파이프라인입니다.

**기술 스택:**
- **AI 모델:** Google Gemini 3 Flash
- **실행 환경:** Firebase Cloud Functions (v2)
- **파일 암호화 (1차):** AES-256-GCM (파일 전체 암호화)
- **세션 키 암호화 (2차):** HMAC-SHA256 (사용자별 임시 키 생성)
- **데이터베이스:** Firestore
- **파일 저장소:** Firebase Storage
- **클라이언트 DB:** IndexedDB (오프라인 저장용)

---

## Part 1. 비디오 업로드 및 자동 처리 (관리자)

관리자가 비디오를 업로드하면, 아래 과정이 백그라운드에서 자동으로 진행됩니다.

### Step 1: 업로드 및 메타데이터 저장
1.  **파일 업로드 (관리자 페이지):** 관리자가 '비디오 업로드' 대화상자에서 비디오 원본 파일, 제목, 설명 등의 메타데이터를 입력하고 '저장'을 클릭합니다.
2.  **데이터베이스 문서 생성:** `saveEpisodeMetadata` 서버 액션이 호출되어, 입력된 모든 정보와 함께 **`aiProcessingStatus: 'pending'`** 및 **`status.processing: 'pending'`** 상태를 포함한 `episodes` 문서를 Firestore에 생성합니다. 이 'pending' 상태가 전체 파이프라인을 시작하는 **"방아쇠"** 역할을 합니다.

### Step 2: Cloud Function 트리거 및 병렬 처리
1.  **자동 트리거 (`functions/src/index.ts`):** `episodes` 컬렉션에 'pending' 상태의 새 문서가 감지되면, **Cloud Function (`analyzeVideoOnWrite`)**이 자동으로 실행됩니다.
2.  **상태 업데이트:** 함수는 시작과 동시에 `aiProcessingStatus`와 `status.processing` 필드를 'processing'으로 변경하여, 중복 실행을 방지하고 현재 상태를 명확히 합니다.
3.  **두 작업 동시 실행:** 함수는 `Promise.allSettled`를 사용하여 아래의 두 가지 핵심 작업을 **병렬로 동시에** 처리합니다.
    *   **작업 A: AI 콘텐츠 분석 (`runAiAnalysis`)**
    *   **작업 B: 파일 암호화 및 키 저장 (`createEncryptedFile`)**

### Step 3-A: AI 콘텐츠 분석 (`runAiAnalysis`)
1.  **파일 시스템 연동:** 원본 비디오 파일을 임시 로컬 경로에 다운로드합니다.
2.  **Google AI 연동:** 다운로드한 파일을 Google AI File Manager에 업로드하고 서버에서 처리가 완료될 때까지 대기합니다.
3.  **AI 모델 호출 (Gemini):** **Gemini 3 Flash** 모델에 "이 비디오를 분석하여 요약, 전체 대본, 시간대별 자막/설명이 포함된 타임라인을 한국어 JSON으로 만들어줘" 라고 구조화된 데이터 출력을 요청합니다.
4.  **결과 분리 저장:**
    *   AI가 생성한 결과물 중, 용량이 큰 **`transcript`(대본)는 별도의 `.txt` 파일로 분리**하여 Firebase Storage에 저장합니다.
    *   `timeline` 데이터는 **`.vtt` 자막 파일로 변환**하여 Storage에 저장합니다.
    *   대본을 제외한 나머지 분석 결과(요약, 타임라인 등)는 JSON 문자열 형태로 `episodes` 문서의 **`aiGeneratedContent` 필드**에 업데이트합니다.
5.  **상태 완료:** 모든 파일 저장이 끝나면, `aiProcessingStatus`를 **`completed`**로 변경하고, 생성된 파일들의 경로(`transcriptPath`, `subtitlePath`)를 문서에 기록합니다.

### Step 3-B: 파일 암호화 (`createEncryptedFile`) - 1차 암호화
1.  **마스터 키 생성:** 비디오 파일 하나당 유일무이한 **`마스터 암호화 키`(AES-256)**를 생성합니다. 이 키는 이 비디오를 해독할 수 있는 유일한 열쇠입니다.
2.  **파일 암호화 (AES-256-GCM):** 생성한 마스터 키를 사용하여 원본 비디오 파일을 **AES-256-GCM 알고리즘으로 완전히 암호화**합니다. GCM 방식은 데이터의 무결성과 신뢰성을 함께 보장하여 변조를 방지합니다.
3.  **암호화된 파일 저장:** 암호화된 비디오 데이터는 `.lsv` 확장자로 Firebase Storage의 **비공개(private) 경로**에 저장됩니다. 이제 이 파일은 마스터 키 없이는 절대 열 수 없는 '잠긴 상자'가 됩니다.
4.  **마스터 키 별도 보관:** 생성된 **마스터 키는 절대로 `episodes` 문서에 저장하지 않습니다.** 대신, 규칙으로 보호되어 서버에서만 접근 가능한 별도의 컬렉션인 **`video_keys`에 안전하게 보관**합니다.
5.  **상태 완료:** 암호화된 파일의 경로, 파일 크기, 암호화 정보(`encryption` 필드)를 `episodes` 문서에 기록하고, `status.processing`을 **`completed`**, `status.playable`을 **`true`**로 변경합니다.

### Step 4: 최종 정리
1.  작업 A와 B가 모두 끝나면, 더 이상 필요 없는 **원본 비디오 파일을 Storage에서 삭제**하여 저장 공간을 절약하고 보안을 강화합니다.

---

## Part 2. 보안 온라인 스트리밍 (사용자)

사용자가 영상을 재생하면, 아래의 이중 암호화 해제 과정이 실시간으로 진행됩니다.

### Step 1: 재생 준비 (클라이언트 → 서버)
1.  **권한 확인:** 사용자가 영상 재생 버튼을 누르면, 클라이언트는 서버의 `/api/video-url` 엔드포인트에 **비디오 ID**를 전송합니다. 서버는 사용자가 해당 영상을 볼 수 있는 **유효한 구독권**을 가지고 있는지 확인합니다.
2.  **보안 URL 발급:** 구독이 확인되면, 서버는 Firebase Storage에 저장된 **비공개 암호화 파일(`.lsv`)**에 접근할 수 있는 **단기 유효 시간(5분)의 서명된 URL(Signed URL)**을 생성하여 클라이언트에 전달합니다. 이 URL만으로는 영상을 볼 수 없습니다.

### Step 2: 세션 키 요청 (클라이언트 → 서버) - 2차 암호화
1.  **재생 세션 생성:** 클라이언트는 서버의 `/api/play-session` 엔드포인트로 **"재생 세션을 시작하겠다"**고 요청하며, 이때 `videoId`와 `deviceId`를 함께 보냅니다.
2.  **세션 키(Derived Key) 생성:**
    *   서버는 요청을 받고, `video_keys` 비밀 금고에서 해당 비디오의 **'마스터 키'**를 꺼냅니다.
    *   `사용자 ID`와 `기기 ID` 등 고유 정보를 조합한 후, 마스터 키를 사용하여 **HMAC-SHA256 해시**를 적용합니다.
    *   결과적으로, **오직 이 사용자, 이 기기, 이 세션에서만 사용 가능한 일회성 `세션 키(Derived Key)`**가 생성됩니다.
3.  **워터마크 시드 생성:** 서버는 `사용자 ID`를 해싱하여 고유한 **`워터마크 시드`** 문자열을 생성합니다.
4.  **세션 정보 전달:** 서버는 생성된 `세션 키`와 `워터마크 시드`를 클라이언트에 전달합니다. 이 정보들은 매우 짧은 시간 동안만 유효합니다.

### Step 3: 실시간 복호화 및 재생 (클라이언트)
1.  **데이터 다운로드:** 클라이언트는 발급받은 서명된 URL을 통해 암호화된 `.lsv` 비디오 파일을 다운로드하기 시작합니다.
2.  **실시간 복호화:** 비디오 데이터가 들어오는 대로, 클라이언트(브라우저)는 방금 받은 **세션 키**를 사용하여 JavaScript Crypto API로 암호화된 데이터를 **실시간으로 풀면서(복호화)** 재생합니다.
3.  **워터마크 렌더링:** 동시에, 전달받은 `워터마크 시드`를 비디오 플레이어 상단에 여러 개 복제하여 희미하게, 그리고 불규칙하게 움직이는 오버레이로 표시합니다. 이는 화면 녹화를 하더라도 누가 녹화했는지 식별할 수 있는 흔적을 남깁니다.
4.  **재생:** 사용자는 일반 비디오처럼 영상을 시청합니다. 이 모든 복잡한 과정은 백그라운드에서 순식간에 일어나므로 사용자는 인지하지 못합니다.

---

## Part 3. 보안 오프라인 다운로드 및 재생 (사용자)

사용자가 영상을 다운로드하여 오프라인에서 시청하는 과정입니다.

### Step 1: 오프라인 라이선스 요청 (클라이언트 → 서버)
1.  **다운로드 요청:** 사용자가 다운로드 버튼을 클릭하면, 클라이언트는 서버의 `/api/offline-license` 엔드포인트로 `videoId`와 `deviceId`를 전송합니다.
2.  **오프라인 키 생성:**
    *   서버는 구독 권한을 확인하고, 해당 비디오의 '마스터 키'를 가져옵니다.
    *   온라인 재생과 유사하지만, 이번에는 **만료 시간(예: 7일 후)을 포함**하여 `오프라인용 세션 키`를 생성합니다. (`HMAC(마스터키, 사용자ID|기기ID|비디오ID|**만료타임스탬프**)`)
    *   마찬가지로 `워터마크 시드`도 생성합니다.
3.  **라이선스 발급:** 서버는 생성된 `오프라인용 세션 키`, `만료 시간`, `워터마크 시드`를 포함한 **오프라인 라이선스**를 클라이언트에 전달합니다.

### Step 2: 다운로드 및 저장 (클라이언트)
1.  **암호화된 파일 다운로드:** 클라이언트는 `/api/video-url`을 통해 서명된 URL을 받아, 암호화된 `.lsv` 파일 전체를 다운로드합니다.
2.  **로컬 저장 (IndexedDB):** 다운로드한 **암호화된 비디오 데이터**와 방금 발급받은 **오프라인 라이선스**를 함께 브라우저의 `IndexedDB`에 안전하게 저장합니다.

### Step 3: 오프라인 재생 (클라이언트)
1.  **데이터 로드:** 사용자가 오프라인 상태에서 다운로드한 영상을 재생하면, 앱은 `IndexedDB`에서 암호화된 비디오와 오프라인 라이선스를 불러옵니다.
2.  **만료 여부 확인:** 재생 전, 현재 시간이 라이선스에 저장된 `만료 시간`을 지났는지 확인합니다. 만료되었다면 재생을 차단하고 사용자에게 알립니다.
3.  **오프라인 복호화 및 재생:** 만료되지 않았다면, 저장된 `오프라인용 세션 키`를 사용하여 비디오 데이터를 실시간으로 복호화하며 재생합니다. 저장된 `워터마크 시드`를 이용해 워터마크도 동일하게 표시됩니다.
4.  **기간 만료:** 정해진 기간(예: 7일)이 지나면, 해당 라이선스는 더 이상 유효하지 않으므로 비디오는 재생되지 않습니다.
